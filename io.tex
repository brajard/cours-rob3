% !TEX encoding = IsoLatin9

%%%%%%%%%%%%%%%%%%%%% SECTION 1
\section{Entrées/Sorties}
\begin{frame}
  \begin{columns}
    \column{4.8cm}
    \tableofcontents[currentsection,hideothersubsections]
    \column{7cm}
     \centering{
      \includegraphics[width=5cm]{fig/inout.jpg}
}
  \end{columns}
  
\end{frame}

\begin{frame}[fragile]
\frametitle{Les entrées/sorties}
\begin{itemize}
\item Affichage de caractères à l'écran : \\
\bvrb|printf(£textitµchaine_de_caracteres§,£textitµvariables§);|\\
\vspace{0.5cm}
\item Lecture de caractères au clavier : \\
\bvrb|scanf(£textitµformat§,£textitµadresses§);|\\
\vspace{0.5cm}
\item Pour utiliser ces fonctions, il est nécessaire d'inclure au programme
la bibliothèque \Verb|stdio.h| gérant les entrées sorties :
\begin{codeblock}{}
\lstset{escapeinside={§§}}
%\lstset{basicstyle=\scriptsize}
\begin{codeC}
#include <stdio.h>
\end{codeC}
\end{codeblock}

\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Comment fonctionne le \bvrb|scanf| ?}
\begin{figure}
\centering
\begin{tikzpicture} [
  auto,
  line/.style     = { draw, thick, color=red,->, shorten >=2pt },
  node distance = 4cm
]
\node[inner sep=0pt] (clavier)
{\includegraphics[width=3cm]{./fig/clavier.png}};
\node[inner sep=0pt,right of=clavier] (fils) 
{\includegraphics[width=3cm]{./fig/cables.png}};
\node[inner sep=0pt,right of=fils] (proc) 
{\includegraphics[width=3cm]{./fig/carte_mere.jpg}};
\node [below of = clavier,yshift = +2cm] (input) {{\Large 5}};
\node [below of = proc, yshift  = +2cm] (mem)
{
  \begin{tabular}{p{0.9em}|p{0.9em}|p{0.9em}|p{0.9em}|p{0.9em}}
    \hline
    ... & & 5 & & ... \\
    \hline
    \multicolumn{2}{p{1.8em}}{} &\multicolumn{1}{p{0.9em}}{\texttt{\&n}} & \multicolumn{2}{p{1.8em}}{}  \\
  \end{tabular}
};
\path [line] (input) -- (mem);
\end{tikzpicture}
\end{figure}

\begin{columns}
\column{0.45\textwidth}
\begin{codeblock}{}
\lstset{escapeinside={§§}}
%\lstset{basicstyle=\scriptsize}
\begin{codeC}
scanf("%d",&n);
\end{codeC}
\end{codeblock}
\column{0.45\textwidth}
La valeur 5 est affectée à la variable \Verb|n|.

La case mémoire adressée par \Verb|&n| contient la 
valeur 5
\end{columns}


\end{frame}


\begin{frame}[fragile]
\frametitle{Comment fonctionne le \bvrb|printf| ?}
\begin{figure}
\centering
\begin{tikzpicture} [
  auto,
  line/.style     = { draw, color=red, thick, ->, shorten >=2pt },
  node distance = 4cm
]
\node[inner sep=0pt] (proc) 
{\includegraphics[width=3cm]{./fig/carte_mere.jpg}};
\node[inner sep=0pt,right of=proc] (fils) 
{\includegraphics[width=3cm]{./fig/cables.png}};
\node[inner sep=0pt, right of=fils] (ecran)
{\includegraphics[width=3cm]{./fig/ecran.jpg}};

\node [below of = ecran,yshift = +2cm] (output) {{\Large 5}};
\node [below of = proc, yshift  = +2cm] (mem)
{
  \begin{tabular}{p{0.9em}|p{0.9em}|p{0.9em}|p{0.9em}|p{0.9em}}
    \hline
    ... & & 5 & & ... \\
    \hline
    \multicolumn{2}{p{1.8em}}{} &\multicolumn{1}{p{0.9em}}{\texttt{\&n}} & \multicolumn{2}{p{1.8em}}{}  \\
  \end{tabular}
};
\path [line] (mem) -- (output);
\end{tikzpicture}
\end{figure}

\begin{columns}
\column{0.45\textwidth}
\begin{codeblock}{}
\lstset{escapeinside={§§}}
%\lstset{basicstyle=\scriptsize}
\begin{codeC}
printf("%d",n);
\end{codeC}
\end{codeblock}
\column{0.45\textwidth}
Affiche la valeur de la variable \Verb|n|.

La case mémoire adressée par \Verb|&n| est affiché.
\end{columns}


\end{frame}

\begin{frame}[fragile]
\frametitle{Les codes formats}
\begin{table}
\begin{tabular}{|l|l|}
\hline
\bvrb|%c| & Caractère \\
\hline
\bvrb|%d| & Entier signé \\
\hline
\bvrb|%u| & Entier non signé \\
\hline
\bvrb|%x| ou \bvrb|%X| & Entier en hexadécimal \\
\hline
\bvrb|%o| & Entier en octal\\
\hline
\bvrb|%ld| & Entier long signé \\
\hline
\bvrb|%lu| & Entier long non signé \\
\hline
\bvrb|%lx| ou \bvrb|%lX| & Entier long en hexadécimal \\
\hline
\bvrb|%f| & Réel simple précision avec virgule flottante \\
\hline
\bvrb|%e| ou \bvrb|%E| & Réel simple précision avec exposant e ou E \\
\hline
\bvrb|%lf| & Réel double avec virgule flottante \\
\hline
\bvrb|%le| ou \bvrb|%lE| & Réel double avec exposant e ou E \\
\hline
\bvrb|%Lf| & Réel long double avec virgule flottante \\
\hline
\bvrb|%Le| ou \bvrb|%LE| & Réel long double avec exposant e ou E \\
\hline
\bvrb|%s| & Chaîne de caractères \\
\hline
\bvrb|%p| & Pointeur \\
\hline
\end{tabular}
\end{table}

\end{frame}

\begin{frame}[fragile]
\frametitle{Compléments sur les formats}

\begin{itemize}
\item Autres formats d'affichage :\\
\begin{description}
\item[]\bvrb|\n| : Passage à la ligne.\\
\item[]\bvrb|\t| : Tabulation.\\
\item[]\bvrb|\0| : Fin de chaîne.\\
\item[]\bvrb|\%| : Signe pourcentage.\\
\end{description}
\item On peut précéder les codes des réels de deux entiers : \bvrb|%n.p|
\begin{description}
\item[]\bvrb|n| : largeur minimale \\
\item[]\bvrb|p| : précisions \\
\end{description}
\item On peut précéder les codes des entiers d'un entier :
\begin{description}
\item[]\bvrb|%n| : largeur minimale de n.\\
\item[]\bvrb|%0n| : largeur minimal de n avec les blancs comblés par des zéros.\\
\end{description}

\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Exemples}

\begin{codeblock}{}
\lstset{escapeinside={§§}}
%\lstset{basicstyle=\scriptsize}
\begin{codeC}
 int n=34 ;
 float x = 3.1,y=1.525;
 printf("_%d_%3d_%1d_%03d_\n",n,n,n,n);
 printf("_%f_%3.2f_\n",x,x);
 printf("_%f_%5.2f_%2.2f_\n",y,y,y);
\end{codeC}
\end{codeblock}
\begin{termblock}{Test d'exécution}
\lstset{escapeinside={§§}}
\begin{Verbatim}
_34_ 34_34_034_
_3.100000_3.10_
_1.525000_ 1.52_1.52_
\end{Verbatim}
\end{termblock}


\end{frame}

\begin{frame}[fragile]
\frametitle{\bvrb|scanf| : comment ça se passe ?}
\begin{codeblock}{}
\vspace{-0.2cm}
\lstset{escapeinside={§§}}
%\lstset{basicstyle=\scriptsize}
\begin{codeC}
int a; float x ;
scanf("%d %f",&a,&x);
\end{codeC}
\vspace{-0.2cm}
\end{codeblock}
\begin{enumerate}[<+->]
\item Si le tampon est vide, le programme s'interrompt pour laisser
l'utilisateur taper au clavier.\\
\item Dès le la touche \Verb|Entrée| est frappée, la séquence des élements
entrés est stockée dans une zone mémoire appelée \red{tampon}.\\
\item La directive \bvrb|scanf| consomme la mémoire tampon en fonction
du format indiqué et stocke les éléments convertis dans les variables :\\
\begin{itemize}
\item Si le tampon est vide avant que le format du \bvrb|scanf| ne soit
entièrement converti, on retourne à l'étape 1.\\
\item Si le format dans le \bvrb|scanf| ne correspond pas au prochain caractère de la séquence
entrée au clavier, \red{la conversion d'interrompt et le programme continue}.\\
\item Si la conversion est entièrement terminée, le programme continue
mais \red{il peut rester encore des éléments dans le tampon}.\\
\end{itemize}
\end{enumerate}

\end{frame}

\begin{frame}[t,fragile]
\frametitle{Illustration}
\begin{columns}[t]
\column{0.4\textwidth}
\begin{codeblock}{}
\vspace{-0.2cm}
\lstset{escapeinside={§§}}
%\lstset{basicstyle=\scriptsize}
\begin{codeC}
int a; float x ;
scanf("%d %f",&a,&x);§\tikz[remember picture,baseline=-.5ex]\coordinate(code);§
\end{codeC}
\vspace{-0.2cm}
\end{codeblock}
\vspace{0.5cm}
\begin{visibleenv}<3->
\begin{termblock}{au clavier : \tikz[remember picture,baseline=-.5ex]\coordinate(clav);   }
\lstset{escapeinside={§§}}
\begin{lstlisting}
3 2.5 (Entrée)§\tikz[remember picture,baseline=-.5ex]\coordinate(term);§
\end{lstlisting}
\end{termblock}
\vspace{0.4cm}
\end{visibleenv}

\begin{visibleenv}<6->

L'espace est ignoré \tikz[remember picture,baseline=-.5ex]\coordinate(space);\\
\red{sauf} si le format \bvrb|%c|
(caractère) est spécifié.
\end{visibleenv}

\column{0.55\textwidth}
\vspace{-0.5cm}
\begin{figure}
  % \centering
  \begin{tikzpicture}[
    auto,
    remember picture,
    node distance = 2cm,
    fond/.style = {rectangle,draw=blue!80, rectangle, minimum width=5.5cm, minimum height = 1.5cm, fill=blue!20},
    head/.style={regular polygon, xshift=-2.27cm,yshift=0.13cm,fill=black,rotate around = {60:(0,0)},regular polygon sides = 3, inner sep=0.05cm},
    ]
    \node <2->(boite1) [fond]{};
    \node <4->(boite2) [fond,below of = boite1]{};
    \node <5->(boite3) [fond,below of = boite2]{};
    \node <7->(boite4) [fond,below of = boite3]{};
    
    \node <2->(tampon1)
    {
      \begin{tabular}{|p{0.35cm}|p{0.35cm}|p{0.35cm}|p{0.35cm}|p{0.1cm}|p{0.35cm}|p{0.35cm}|}
        \multicolumn{4}{c}{tampon}& \multicolumn{1}{c}{} & \multicolumn{1}{c}{\texttt{\&a}} & \multicolumn{1}{c}{\texttt{\&x}} \\
        \cline{1-4}\cline{6-7}
        & & & & & & \\
        \cline{1-4}\cline{6-7}
      \end{tabular}
    };
    \node <2-> (tik1) [head] {};
    
    \node <4-> (tampon2) [below of = boite1]
    {
      \begin{tabular}{|p{0.35cm}|p{0.35cm}|p{0.35cm}|p{0.35cm}|p{0.1cm}|p{0.35cm}|p{0.35cm}|}
        \multicolumn{4}{c}{tampon}& \multicolumn{1}{c}{} & \multicolumn{1}{c}{\texttt{\&a}} & \multicolumn{1}{c}{\texttt{\&x}} \\
        \cline{1-4}\cline{6-7}
        \footvrb|3| & & \footvrb|2.5| & \footvrb|\n| & & & \\
        \cline{1-4}\cline{6-7}
      \end{tabular}
    };

\node <4->(tik2) [below of =boite1, head] {};
        \node  <5-> (tampon3) [below of = boite2]
    {
      \begin{tabular}{|p{0.35cm}|p{0.35cm}|p{0.35cm}|p{0.35cm}|p{0.1cm}|p{0.35cm}|p{0.35cm}|}
        \multicolumn{4}{c}{tampon}& \multicolumn{1}{c}{} & \multicolumn{1}{c}{\texttt{\&a}} & \multicolumn{1}{c}{\texttt{\&x}} \\
        \cline{1-4}\cline{6-7}
        & \footvrb|2.5| & \footvrb|\n| & & & 3 & \\
        \cline{1-4}\cline{6-7}
      \end{tabular}
    };
    \node <5->(tik3) [below of =boite2, head] {};
    \node <7->(tampon4) [below of = boite3]
    {
      \begin{tabular}{|p{0.35cm}|p{0.35cm}|p{0.35cm}|p{0.35cm}|p{0.1cm}|p{0.35cm}|p{0.35cm}|}
        \multicolumn{4}{c}{tampon}& \multicolumn{1}{c}{} & \multicolumn{1}{c}{\texttt{\&a}} & \multicolumn{1}{c}{\texttt{\&x}} \\
        \cline{1-4}\cline{6-7}
        \footvrb|\n| & & & & & 3 & 2.5 \\
        \cline{1-4}\cline{6-7}
      \end{tabular}
    };
    \node <7->(tik4) [below of =boite3, head] {};
  \end{tikzpicture}
\end{figure}

\begin{tikzpicture}[
  remember picture,
  overlay,
  line/.style= {draw=red, very thick, ->},
  ]
  \draw <2-> [line] ($(code)+(0,0)$) -- ($(tampon1.west)+(0,-0.2)$) ;
  \draw<3-> [line] ($(tampon1.west)+(0,-0.6)$) -- ($(clav)+(0,0)$) ;
\draw <4-> [line] ($(term)+(0,0)$) -- ($(tampon2.west)+(0,-0.2)$) ;
  \draw<5-> [line] ($(tampon2.west)+(0.5,-0.4)$) -- ($(tampon3.east)+(-1.6,+0.1)$) node[midway,above,sloped]{\red{\texttt{\%d}}};
  \draw<7-> [line] ($(tampon3.west)+(1.5,-0.4)$) -- ($(tampon4.east)+(-0.6,+0.1)$) node[midway,above,sloped]{\red{\texttt{\%f}}};
  \draw<6-> [->] ($(tampon3.west)+(0,-0.2)$) -- (space) ;

\end{tikzpicture}

\end{columns}

\end{frame}

\begin{frame}[fragile]
\frametitle{Faire attention}
\begin{itemize}
\item Les caractères peuvent rester dans le tampon (Exemple~1).\\
\vspace{0.4cm}
\item Le caractère espace est pris en compte seulement dans le cas
du formateur \bvrb|%c| (Exemple~2).\\
\vspace{0.4cm}
\item La conversion peut s'arrêter et ainsi des variables peuvent ne pas
être attribuées (Exemple~3).\\
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]
\frametitle{\label{exemple1} Exemple 1}
\begin{codeblock}{}
\vspace{-0.2cm}
\lstset{escapeinside={§§}}
%\lstset{basicstyle=\scriptsize}
\begin{codeC}
int a; float x ;
printf("Ecrire a : ");
scanf("%d",&a);
printf("Ecrire x :");
scanf("%f,&x);
printf("Fin\n");
\end{codeC}
\vspace{-0.2cm}
\end{codeblock}
\vspace{-0.5cm}
\begin{columns}[t]
\column{0.48\textwidth}
\begin{termblock}{Test d'exécution}
\lstset{escapeinside={§§}}
\begin{Verbatim}
Ecrire a : 32 (Entrée)
Ecrire x : 2.1 (Entrée)
Fin
\end{Verbatim}
\end{termblock}
Ce fonctionnement est normal :
Le 1er \bvrb|scanf| consomme l'entier \verb|32|
et le 2ème consomme le réel \verb|2.1|.

\column{0.48\textwidth}
\begin{termblock}{Test d'exécution}
\lstset{escapeinside={§§}}
\begin{Verbatim}
Ecrire a : 3 2 (Entrée)
Ecrire x : 
Fin
\end{Verbatim}
\end{termblock}
On a séparé (par erreur) le 3 et le 2.
Ce qui fait que le premier \bvrb|scanf| ne consomme
que le 3. Le deuxième \bvrb|scanf| consomme le 2 sans donner la main
à l'utilisateur.
\end{columns}

\end{frame}

\begin{frame}[fragile]
\frametitle{Solution}
On peut écrire une petite procédure qui vide le tampon après chaque scanf.
\begin{codeblock}{}
\vspace{-0.2cm}
\lstset{escapeinside={§§}}
%\lstset{basicstyle=\scriptsize}
\begin{codeC}
int a ; float x ;
char c;
printf("Ecrire a : ");
scanf("%d",&a);
do {
  c = getchar();
  } while (c!='\n' && c!=EOF);
printf("Ecrire x : ";
scanf("%f",&x);
\end{codeC}
\vspace{-0.2cm}
\end{codeblock}

\vspace{0.2cm}

\bvrb|getchar| lit un caractère \Verb|c| dans le tampon
tant que (\bvrb|while|) \Verb|c| est différent de \Verb|\n| ou
\Verb|EOF| (fin du tampon).

\end{frame}

\begin{frame}[t,fragile]
\frametitle{\label{exemple2} Exemple 2}
\begin{codeblock}{}
\vspace{-0.2cm}
\lstset{escapeinside={§§}}
%\lstset{basicstyle=\scriptsize}
\begin{codeC}
char c;
scanf("%c",&c);
\end{codeC}
\vspace{-0.2cm}
\end{codeblock}


\centering{
un espace\\
\tikz[remember picture,baseline=-.5ex]\coordinate(sp1);
}
\vspace{-0.5cm}


\begin{columns}[t]
\column{0.48\textwidth}
\begin{termblock}{Test d'exécution}
\lstset{escapeinside={§§}}
\begin{lstlisting}
A (Entrée)
\end{lstlisting}
\end{termblock}

La variable \verb|c| contient \verb|'A'|.

\column{0.48\textwidth}
\begin{termblock}{Test d'exécution}
\lstset{escapeinside={§§}}
\begin{lstlisting}
§\tikz[remember picture,baseline=-.5ex]\coordinate(sp2);§ A (Entrée)
\end{lstlisting}
\end{termblock}
La variable \verb|c| contient \verb|' '|.

\end{columns}

\begin{tikzpicture}[auto, remember picture, overlay]
\draw[thick,->, shorten >= 3pt] (sp1) -- (sp2) ;
\end{tikzpicture}
\end{frame}

\begin{frame}[t,fragile]
\frametitle{Solution}
\begin{codeblock}{}
\vspace{-0.2cm}
\lstset{escapeinside={§§}}
%\lstset{basicstyle=\scriptsize}
\begin{codeC}
char c;
scanf("§\tikz[remember picture,baseline=-.5ex]\coordinate(spc1);§ %c",&c);
\end{codeC}
\vspace{-0.2cm}
\end{codeblock}
\tikz[remember picture,baseline=-.5ex]\coordinate(spc2);
L'espace indique qu'on ignore les espaces avant le caractère\\
\vspace{0.5cm}
\centering{
un espace\\
\tikz[remember picture,baseline=-.5ex]\coordinate(sp1);
}
\vspace{-0.5cm}


\begin{columns}[t]
\column{0.48\textwidth}
\begin{termblock}{Test d'exécution}
\lstset{escapeinside={§§}}
\begin{lstlisting}
A (Entrée)
\end{lstlisting}
\end{termblock}

La variable \verb|c| contient \verb|'A'|.

\column{0.48\textwidth}
\begin{termblock}{Test d'exécution}
\lstset{escapeinside={§§}}
\begin{lstlisting}
§\tikz[remember picture,baseline=-.5ex]\coordinate(sp2);§ A (Entrée)
\end{lstlisting}
\end{termblock}
La variable \verb|c| contient \verb|'A'|.

\end{columns}

\begin{tikzpicture}[auto, remember picture, overlay]
\draw[thick,->, shorten >= 3pt] (sp1) -- (sp2) ;
\draw[thick,->, shorten >= 13pt] (spc1) -- (spc2) ;

\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
\frametitle{Exemple 3}
\begin{codeblock}{}
\vspace{-0.2cm}
\lstset{escapeinside={§§}}
%\lstset{basicstyle=\scriptsize}
\begin{codeC}
int a ; float x ;
scanf("%d %f",&a,&x);
\end{codeC}
\vspace{-0.2cm}
\end{codeblock}


\begin{termblock}{Test d'exécution}
\lstset{escapeinside={§§}}
\begin{lstlisting}
3 k (Entrée)
\end{lstlisting}
\end{termblock}

La variable \verb|a| a bien été initialisée à 3, mais la variable
\verb|x| n'a pas été initialisée (impossible de convertir \verb|k| en
\bvrb|float|).

\end{frame}

\begin{frame}[fragile]
\frametitle{Solution}
\begin{codeblock}{}
\vspace{-0.2cm}
\lstset{escapeinside={§§}}
%\lstset{basicstyle=\scriptsize}
\begin{codeC}
int a ; float x ;
int status ;
status = scanf("%d %f",&a,&x);
if (status != 2)
  {...
\end{codeC}
\vspace{-0.2cm}
\end{codeblock}


\begin{termblock}{Test d'exécution}
\lstset{escapeinside={§§}}
\begin{lstlisting}
3 k (Entrée)
\end{lstlisting}
\end{termblock}

La variable \verb|status| sera égale à 1 (et non comme attendu
à 2). On peut donc prévoir un traitement spécifique à l'aide
d'une structure \bvrb|if|.
\end{frame}



